#!/usr/bin/env ruby

$:.unshift(File.expand_path("../../lib", __FILE__))

require "trollop"
require "timestamps"
require "zip"

module TRecs
  class MessageRecorder
    include FileUtils

    def initialize(options={})
      @file_name = options.fetch(:file_name)
      delete_file

      @message   = options.fetch(:message)
      @step      = options.fetch(:step) { 100 }
    end

    def record
      start_recording

      message.each_char.each_with_object("") do |current_char, current_msg|
        current_msg << current_char
        create_frame(current_msg.dup, timestamp_for(current_msg))
      end

      finish_recording
    end

    def create_frame(content, timestamp)
      frames[timestamp] = content
    end

    private
    attr_reader :file_name, :message, :frames, :step

    def start_recording
      @frames = {}
    end

    def finish_recording
      Zip::File.open(file_name, Zip::File::CREATE) do |trecs_file|
        frames.each do |timestamp, content|
          Tempfile.open(timestamp.to_s) do |temp_file|
            temp_file.write(content)
            trecs_file.add(timestamp.to_s, temp_file)
          end
        end
      end
    end

    def delete_file
      rm file_name if File.exists? file_name
    end

    def timestamp_for(message)
      (message.size - 1) * step
    end
  end
end
#-------------------------

options = Trollop::options do
  opt :file_name, "File to process",                     short: 'f', type: String
  opt :message,   "Message to record",                   short: 'm', type: String
  opt :step,      "Time between frames in milliseconds", short: 's', default: 100
end

if options[:file_name]
  recorder = TRecs::MessageRecorder.new(options)
  recorder.record
else
  puts "Please give a file name"
end
#recorder = TRecs::MessageRecorder.new(options)
